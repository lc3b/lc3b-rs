// Horizontal whitespace only (no newlines)
ws = _{ " " | "\t" }

program = {
    SOI ~ (line ~ NEWLINE)* ~ line? ~ EOI
}

line = {
    ws* ~ (directive_line | instruction_line | label_only_line | comment_line | empty_line)
}

// Assembler directive (e.g., .ORIG, .FILL, .END)
directive_line = {
    (label ~ ws*)? ~ directive ~ ws* ~ (";" ~ ws* ~ comment)?
}

directive = {
    orig_directive | end_directive | fill_directive | blkw_directive | stringz_directive
}

orig_directive = {
    ^".ORIG" ~ ws+ ~ hex_literal
}

end_directive = {
    ^".END"
}

fill_directive = {
    ^".FILL" ~ ws+ ~ (hex_literal | literal | identifier)
}

blkw_directive = {
    ^".BLKW" ~ ws+ ~ (hex_literal | literal)
}

stringz_directive = {
    ^".STRINGZ" ~ ws+ ~ string_literal
}

string_literal = {
    "\"" ~ string_content ~ "\""
}

string_content = {
    (!("\"" | NEWLINE) ~ ANY)*
}

hex_literal = {
    ("x" | "X") ~ ASCII_HEX_DIGIT+
}

// Label on its own line (no instruction)
label_only_line = {
    label ~ ws* ~ (";" ~ ws* ~ comment)?
}

// Instruction with optional preceding label
instruction_line = {
    (label ~ ws*)? ~ instruction ~ ws* ~ (";" ~ ws* ~ comment)?
}

label = {
    identifier ~ ws* ~ ":"
}

comment_line = {
    ";" ~ ws* ~ comment
}

empty_line = {
    ws*
}

instruction = {
    opcode ~ ws+ ~ operands
}

opcode = {
    ASCII_ALPHA+
}

operands = {
    ((register | hex_literal | literal | identifier) ~ ws* ~ ","? ~ ws*)+
}

comment = {
    (!NEWLINE ~ ANY)*
}

register = {
    ("R" | "r") ~ ASCII_DIGIT
}

literal = {
    "#"? ~ "-"? ~ ASCII_DIGIT+
}

identifier = {
    !register ~ ASCII_ALPHA ~ (ASCII_ALPHA | ASCII_DIGIT | "_")*
}
