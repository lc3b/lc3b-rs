// LC-3B C Subset Grammar
// A minimal C grammar for generating LC-3B assembly

// Whitespace and comments
WHITESPACE = _{ " " | "\t" | "\r" | "\n" }
COMMENT = _{ line_comment | block_comment }
line_comment = { "//" ~ (!"\n" ~ ANY)* }
block_comment = { "/*" ~ (!"*/" ~ ANY)* ~ "*/" }

// Entry point
program = {
    SOI ~ top_level_item* ~ EOI
}

top_level_item = {
    function_definition | global_declaration
}

// Function definitions
function_definition = {
    return_type ~ identifier ~ "(" ~ parameter_list? ~ ")" ~ compound_statement
}

return_type = {
    void_type | int_type | uint16_type | short_type | char_type
}

void_type = { "void" }
int_type = { "int" }
uint16_type = { "uint16_t" }
short_type = { "unsigned"? ~ "short" }
char_type = { "char" }

parameter_list = {
    parameter ~ ("," ~ parameter)*
}

parameter = {
    type_specifier ~ identifier
}

type_specifier = {
    pointer_type | int_type | uint16_type | short_type | char_type
}

pointer_type = {
    (int_type | uint16_type | short_type | char_type) ~ "*"
}

// Statements
compound_statement = {
    "{" ~ block_item* ~ "}"
}

block_item = {
    declaration | statement
}

statement = {
    compound_statement
    | for_statement
    | while_statement
    | if_statement
    | return_statement
    | expression_statement
    | empty_statement
}

empty_statement = { ";" }

expression_statement = {
    expression ~ ";"
}

// Variable declarations
declaration = {
    type_specifier ~ init_declarator_list ~ ";"
}

global_declaration = {
    type_specifier ~ init_declarator_list ~ ";"
}

init_declarator_list = {
    init_declarator ~ ("," ~ init_declarator)*
}

init_declarator = {
    identifier ~ ("=" ~ initializer)?
}

initializer = {
    assignment_expression | string_literal
}

// Control flow
for_statement = {
    "for" ~ "(" ~ for_init? ~ ";" ~ expression? ~ ";" ~ expression? ~ ")" ~ statement
}

for_init = {
    declaration_no_semi | expression
}

declaration_no_semi = {
    type_specifier ~ init_declarator_list
}

while_statement = {
    "while" ~ "(" ~ expression ~ ")" ~ statement
}

if_statement = {
    "if" ~ "(" ~ expression ~ ")" ~ statement ~ ("else" ~ statement)?
}

return_statement = {
    "return" ~ expression? ~ ";"
}

// Expressions (precedence from lowest to highest)
expression = {
    assignment_expression
}

assignment_expression = {
    (identifier ~ assignment_operator ~ assignment_expression)
    | conditional_expression
}

assignment_operator = {
    "=" | "+=" | "-=" | "&=" | "|=" | "^="
}

conditional_expression = {
    logical_or_expression
}

logical_or_expression = {
    logical_and_expression ~ ("||" ~ logical_and_expression)*
}

logical_and_expression = {
    bitwise_or_expression ~ ("&&" ~ bitwise_or_expression)*
}

bitwise_or_expression = {
    bitwise_xor_expression ~ ("|" ~ !"|" ~ bitwise_xor_expression)*
}

bitwise_xor_expression = {
    bitwise_and_expression ~ ("^" ~ bitwise_and_expression)*
}

bitwise_and_expression = {
    equality_expression ~ ("&" ~ !"&" ~ equality_expression)*
}

equality_expression = {
    relational_expression ~ (equality_operator ~ relational_expression)*
}

equality_operator = { "==" | "!=" }

relational_expression = {
    shift_expression ~ (relational_operator ~ shift_expression)*
}

relational_operator = { "<=" | ">=" | "<" | ">" }

shift_expression = {
    additive_expression ~ (shift_operator ~ additive_expression)*
}

shift_operator = { "<<" | ">>" }

additive_expression = {
    multiplicative_expression ~ (additive_operator ~ multiplicative_expression)*
}

additive_operator = { "+" | "-" }

multiplicative_expression = {
    unary_expression ~ (multiplicative_operator ~ unary_expression)*
}

multiplicative_operator = { "*" | "/" | "%" }

unary_expression = {
    (unary_operator ~ unary_expression)
    | postfix_expression
}

unary_operator = { "!" | "~" | "-" | "+" | "*" | "&" | "++" | "--" }

postfix_expression = {
    primary_expression ~ postfix_suffix*
}

postfix_suffix = {
    function_call_args
    | array_subscript
    | "++"
    | "--"
}

function_call_args = {
    "(" ~ argument_list? ~ ")"
}

array_subscript = {
    "[" ~ expression ~ "]"
}

argument_list = {
    assignment_expression ~ ("," ~ assignment_expression)*
}

primary_expression = {
    "(" ~ expression ~ ")"
    | integer_literal
    | char_literal
    | string_literal
    | identifier
}

// Literals
integer_literal = @{
    hex_literal | decimal_literal
}

hex_literal = @{
    "0" ~ ("x" | "X") ~ ASCII_HEX_DIGIT+
}

decimal_literal = @{
    "0" | (ASCII_NONZERO_DIGIT ~ ASCII_DIGIT*)
}

char_literal = {
    "'" ~ char_content ~ "'"
}

char_content = {
    escape_sequence | (!("'" | "\\") ~ ANY)
}

string_literal = {
    "\"" ~ string_content ~ "\""
}

string_content = {
    (escape_sequence | (!("\"" | "\\") ~ ANY))*
}

escape_sequence = {
    "\\" ~ ("n" | "r" | "t" | "\\" | "'" | "\"" | "0" | ("x" ~ ASCII_HEX_DIGIT{2}))
}

// Identifiers
identifier = @{
    !keyword ~ (ASCII_ALPHA | "_") ~ (ASCII_ALPHANUMERIC | "_")*
}

keyword = {
    ("void" | "int" | "uint16_t" | "short" | "unsigned" | "char"
    | "if" | "else" | "for" | "while" | "return") ~ !(ASCII_ALPHANUMERIC | "_")
}
